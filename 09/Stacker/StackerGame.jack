/*Stacking game press down to drop block, 
press q to quit, 
if you can stack 10 blocks you win */

class StackerGame {
   field Block startingBlock; // the staring block to stack on
   field Block currentBlockToStack;
   field int currentStackHeight;
   field boolean exit;
   field int direction;

   constructor StackerGame new() {
      let startingBlock = Block.new(225, 234); 
      let direction = 0;  // initial state is no movement
      let currentStackHeight = 40;
      let exit = false;
      return this; 
   }

      /** Disposes this game. */
   method void dispose() {
      do startingBlock.dispose();
      do currentBlockToStack.dispose();
      do Memory.deAlloc(this);
      return;
   }

   method void moveStackingBlock() {
      if (direction = 2) { 
         if(currentBlockToStack.getIsBlockDropped()) {
               let currentStackHeight = currentStackHeight + 20;
               do currentBlockToStack.setStackHeight(currentStackHeight);
               let direction = 0;
               do hasGameEnded();
               if(~exit) {
                  do run();
               }
         }
         else
         {
               do currentBlockToStack.dropBlock();
         }
      }
      do Sys.wait(5);  // delays the next movement
      return;
   }


   method void run() {
      var char key;  // the key currently pressed by the user
      let currentBlockToStack = Block.new(0, 40);
      do currentBlockToStack.setStackHeight(currentStackHeight);
      
      do displayCountdown();

      while (~exit) {
         // waits for a key to be pressed
         while (key = 0) {
            let key = Keyboard.keyPressed();
            do currentBlockToStack.moveLeftRight();
            do moveStackingBlock();
         }

         if (key = 81)  { let exit = true; }     // q key
         if (key = 133) { let direction = 2; }   // down arrow

         // waits for the key to be released
         while (~(key = 0)) {
            let key = Keyboard.keyPressed();
            do moveStackingBlock();
         }     
     } // while
     return;
   }

   method void displayCountdown() {
      do Output.moveCursor(3, 31);
      do Output.printString("3");
      do Sys.wait(500);
      do Output.moveCursor(3, 31);
      do Output.printString("2");
      do Sys.wait(500);
      do Output.moveCursor(3, 31);
      do Output.printString("1");
      do Sys.wait(500);
      do Output.moveCursor(3, 29);
      do Output.printString("GO!!!");
      do Sys.wait(500);
      do clearCountDown();
      return;
   }

   method void clearCountDown() {
      var int counter;
      let counter = 5;
      while (~(counter = 0)){
         do Output.backSpace();
         let counter = counter - 1;
      }
      return;
   }

   method void hasGameEnded() {
      do checkGameOver();
      do checkWinner();
      return;
   }

   method void checkGameOver() {
      if(~exit){
         if (currentBlockToStack.getIsGameOver()) {
         //empty the playing field with giant rectangle
         do Screen.setColor(false);
         do Screen.drawRectangle(0, 60, 510, 254);
         //display game over
         do Output.moveCursor(7, 27);
         do Output.printString("Game Over");
         let exit = true;
         } 
      }
      return;
   }   

   method void checkWinner() {
      if(~exit){
         if (currentStackHeight = 200) {
         //empty the playing field with giant rectangle
         do Screen.setColor(false);
         do Screen.drawRectangle(0, 60, 510, 254);
         //display game over
         do Output.moveCursor(7, 26);
         do Output.printString("YOU WIN!!!");
         let exit = true;
         } 
      }
      return;
   }   
}



//Logic for a good drop
//check that the X is with in so many of the starting block x
//if so can keep stacking to within so close to the y, and then display it on top
//else drop it to 0 - Game Over!
//reshuffle and restack - give another count down?


   //Architecture wise
   //Movement block and "starting block"
   //edit starting block to new size and use the current outline to set the allowed stacking area
   //check movement current x/y if it stacks or not
   //if not it falls to bottom
   //if it does it stacks on top - can be slightly on?
   //block at least halfway on the stack to count or it drops 
   //maybe have it say straightening blocks and rerender?
   //give a count down?
   //should it be 3 blocks or 1 big one?
   //press space to "drop" block
   //high score?
   //lives?
   //different sized drop blocks for different difficulty
   //or different speed?
   //or both?
   